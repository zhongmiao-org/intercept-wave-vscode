name: Test

on:
  push:
    branches: [ main, ark/* ]
  pull_request:
    branches: [ main ]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Unit Tests
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node-version: [18.x, 20.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run unit tests
        run: npm run test:unit

      - name: Generate coverage report
        if: matrix.os == 'ubuntu-latest' && matrix.node-version == '20.x'
        run: npm run test:coverage:ci

      - name: Upload coverage to Codecov
        if: matrix.os == 'ubuntu-latest' && matrix.node-version == '20.x'
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  coverage:
    name: Coverage Report
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate coverage report
        run: npm run test:coverage:ci

      - name: Generate Coverage Badge
        if: github.event_name == 'pull_request'
        run: |
          COVERAGE=$(node -p "
            const fs = require('fs');
            const summary = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
            summary.total.lines.pct.toFixed(2);
          ")
          echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV

      - name: Check coverage and comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // Read coverage summary
            const coverageSummary = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
            const total = coverageSummary.total;

            // Calculate coverage percentages
            const lineCoverage = total.lines.pct;
            const branchCoverage = total.branches.pct;
            const functionCoverage = total.functions.pct;
            const statementCoverage = total.statements.pct;

            // Get previous coverage (from base branch)
            let previousCoverage = null;
            try {
              // Try to get coverage from base branch
              const { data: baseContent } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'coverage/coverage-summary.json',
                ref: context.payload.pull_request.base.ref
              });
              const baseData = Buffer.from(baseContent.content, 'base64').toString('utf8');
              previousCoverage = JSON.parse(baseData).total;
            } catch (error) {
              console.log('Could not fetch base coverage:', error.message);
            }

            // Calculate diff
            const getDiff = (current, previous) => {
              if (!previous) return null;
              const diff = current - previous;
              const sign = diff > 0 ? '+' : '';
              const emoji = diff > 0 ? 'üìà' : diff < 0 ? 'üìâ' : '‚û°Ô∏è';
              return `${emoji} ${sign}${diff.toFixed(2)}%`;
            };

            // Create comment body
            let commentBody = '## üìä Code Coverage Report\n\n';
            commentBody += '| Metric | Coverage | ';
            if (previousCoverage) {
              commentBody += 'Change |\n|--------|----------|--------|\n';
            } else {
              commentBody += '\n|--------|----------|\n';
            }

            const metrics = [
              { name: 'Lines', current: lineCoverage, previous: previousCoverage?.lines.pct },
              { name: 'Branches', current: branchCoverage, previous: previousCoverage?.branches.pct },
              { name: 'Functions', current: functionCoverage, previous: previousCoverage?.functions.pct },
              { name: 'Statements', current: statementCoverage, previous: previousCoverage?.statements.pct }
            ];

            metrics.forEach(metric => {
              const emoji = metric.current >= 80 ? '‚úÖ' : metric.current >= 60 ? '‚ö†Ô∏è' : '‚ùå';
              commentBody += `| ${emoji} ${metric.name} | ${metric.current.toFixed(2)}% |`;
              if (previousCoverage) {
                const diff = getDiff(metric.current, metric.previous);
                commentBody += ` ${diff || 'N/A'} |\n`;
              } else {
                commentBody += '\n';
              }
            });

            commentBody += '\n### Coverage Thresholds\n';
            commentBody += '- ‚úÖ Good: ‚â• 80%\n';
            commentBody += '- ‚ö†Ô∏è Fair: 60-79%\n';
            commentBody += '- ‚ùå Poor: < 60%\n';

            // Add summary
            if (previousCoverage) {
              const totalDiff = lineCoverage - previousCoverage.lines.pct;
              if (totalDiff > 0) {
                commentBody += `\nüéâ **Great job!** Coverage increased by ${totalDiff.toFixed(2)}%\n`;
              } else if (totalDiff < 0) {
                commentBody += `\n‚ö†Ô∏è **Warning:** Coverage decreased by ${Math.abs(totalDiff).toFixed(2)}%\n`;
              } else {
                commentBody += `\n‚ú® Coverage remained stable\n`;
              }
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: commentBody
            });